name: Deploy Ganopa Bot (ECS Fargate)

on:
  push:
    branches: [ "main" ]
    paths:
      - "services/ganopa-bot/**"
      - ".github/workflows/deploy-ganopa-bot.yml"
  workflow_dispatch:
    inputs:
      target_env:
        description: "dev | staging | prod"
        required: true
        default: "dev"
        type: choice
        options: [dev, staging, prod]

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: me-central-1
  AWS_ACCOUNT_ID: "411714852748"
  ECR_REPO_NAME: ganopa-bot

  # IMPORTANT: le nom du container dans la Task Definition Ganopa
  # (√† corriger: ce n'est pas "api" ici)
  CONTAINER_NAME: ganopa-bot

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}
          fetch-depth: 0

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::411714852748:role/GitHubDeployRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve env -> ECS names
        shell: bash
        run: |
          set -euo pipefail

          # Use input if provided (manual dispatch), otherwise default to "dev" (automatic push)
          TARGET_ENV="${{ inputs.target_env || 'dev' }}"

          case "$TARGET_ENV" in
            dev)
              # Ganopa DEV
              CLUSTER="vancelian-dev-api-cluster"
              SERVICE="ganopa-dev-bot-svc"
              ;;
            staging)
              # Ganopa STAGING (√† adapter si tes noms diff√®rent)
              CLUSTER="vancelian-staging-api-cluster"
              SERVICE="ganopa-staging-bot-svc"
              ;;
            prod)
              # Ganopa PROD (√† adapter si tes noms diff√®rent)
              CLUSTER="vancelian-prod-api-cluster"
              SERVICE="ganopa-prod-bot-svc"
              ;;
            *)
              echo "Unknown env" >&2; exit 1;;
          esac

          IMAGE_TAG="${GITHUB_SHA}"
          IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}:${IMAGE_TAG}"

          {
            echo "CLUSTER=${CLUSTER}"
            echo "SERVICE=${SERVICE}"
            echo "IMAGE_TAG=${IMAGE_TAG}"
            echo "IMAGE_URI=${IMAGE_URI}"
          } >> "$GITHUB_ENV"

          echo "Resolved:"
          echo "  ENV=${TARGET_ENV}"
          echo "  CLUSTER=${CLUSTER}"
          echo "  SERVICE=${SERVICE}"
          echo "  CONTAINER_NAME=${CONTAINER_NAME}"
          echo "  IMAGE_URI=${IMAGE_URI}"

      - name: Sanity check - ECS service exists
        shell: bash
        run: |
          set -euo pipefail
          aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --output json > svc.json

          FAILURES_COUNT=$(python - <<'PY'
          import json
          d=json.load(open("svc.json"))
          print(len(d.get("failures", [])))
          PY
          )

          if [[ "$FAILURES_COUNT" != "0" ]]; then
            echo "‚ùå ECS service not found: $SERVICE in cluster $CLUSTER"
            cat svc.json
            exit 1
          fi

          echo "‚úÖ ECS service exists."

      - name: Ensure ECR repository exists
        shell: bash
        run: |
          set -euo pipefail
          if aws ecr describe-repositories \
              --region "$AWS_REGION" \
              --repository-names "$ECR_REPO_NAME" >/dev/null 2>&1; then
            echo "‚úÖ ECR repo exists: ${ECR_REPO_NAME}"
          else
            echo "‚ö†Ô∏è Creating ECR repo: ${ECR_REPO_NAME}"
            aws ecr create-repository \
              --region "$AWS_REGION" \
              --repository-name "$ECR_REPO_NAME" \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256 >/dev/null
          fi

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & push Docker image
        shell: bash
        run: |
          set -euo pipefail
          
          # Debug: Show current Git state
          echo "üîç Git Debug Info:"
          echo "  GITHUB_SHA: ${GITHUB_SHA}"
          echo "  Current commit: $(git rev-parse HEAD)"
          echo "  Current branch: $(git branch --show-current)"
          echo "  Git log -3:"
          git log --oneline -3
          echo ""
          
          # Verify that Python files exist before building
          echo "üîç Verifying Python files exist..."
          ls -la services/ganopa-bot/app/
          test -f services/ganopa-bot/app/main.py || (echo "‚ùå main.py missing!" && exit 1)
          test -f services/ganopa-bot/app/config.py || (echo "‚ùå config.py missing!" && exit 1)
          test -f services/ganopa-bot/app/ai_service.py || (echo "‚ùå ai_service.py missing!" && exit 1)
          test -f services/ganopa-bot/app/ai_prompt.py || (echo "‚ùå ai_prompt.py missing!" && exit 1)
          echo "‚úÖ All Python files verified"
          
          # Verify we're on the right commit
          if [ "$(git rev-parse HEAD)" != "${GITHUB_SHA}" ]; then
            echo "‚ö†Ô∏è  WARNING: Current commit does not match GITHUB_SHA!"
            echo "   Current: $(git rev-parse HEAD)"
            echo "   Expected: ${GITHUB_SHA}"
            echo "   Checking out correct commit..."
            git checkout "${GITHUB_SHA}"
          fi
          
          # Build without cache to ensure latest code is included
          echo "üî® Building Docker image..."
          echo "   Image URI: $IMAGE_URI"
          echo "   Git SHA: ${GITHUB_SHA}"
          docker build --no-cache -t "$IMAGE_URI" -f services/ganopa-bot/Dockerfile services/ganopa-bot
          
          # Verify files are in the image
          echo "üîç Verifying files in Docker image..."
          docker run --rm "$IMAGE_URI" ls -la app/ || true
          docker run --rm "$IMAGE_URI" test -f app/main.py || (echo "‚ùå main.py not in image!" && exit 1)
          docker run --rm "$IMAGE_URI" test -f app/config.py || (echo "‚ùå config.py not in image!" && exit 1)
          echo "‚úÖ All files verified in Docker image"
          
          docker push "$IMAGE_URI"
          echo "‚úÖ Image built and pushed: $IMAGE_URI"
          echo "‚úÖ Git SHA: ${GITHUB_SHA}"
          echo "‚úÖ Image tag should be: ${GITHUB_SHA}"

      - name: Fetch current task definition ARN
        shell: bash
        run: |
          set -euo pipefail
          TASKDEF_ARN=$(aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --query "services[0].taskDefinition" \
            --output text)

          echo "TASKDEF_ARN=$TASKDEF_ARN" >> "$GITHUB_ENV"
          echo "TASKDEF_ARN resolved to: $TASKDEF_ARN"

      - name: Download task definition JSON
        shell: bash
        run: |
          set -euo pipefail
          aws ecs describe-task-definition \
            --region "$AWS_REGION" \
            --task-definition "$TASKDEF_ARN" \
            --query "taskDefinition" \
            --output json > taskdef.json

      - name: Patch task definition image (by container name)
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import json, os
          from pathlib import Path

          td = json.loads(Path("taskdef.json").read_text())

          for k in [
            "taskDefinitionArn","revision","status","requiresAttributes","compatibilities",
            "registeredAt","registeredBy"
          ]:
            td.pop(k, None)

          image_uri = os.environ["IMAGE_URI"]
          container_name = os.environ["CONTAINER_NAME"]

          found = False
          for c in td.get("containerDefinitions", []):
            if c.get("name") == container_name:
              c["image"] = image_uri
              found = True
              break

          if not found:
            names = [c.get("name") for c in td.get("containerDefinitions", [])]
            raise SystemExit(f"‚ùå Container '{container_name}' not found. Found: {names}")

          Path("taskdef_patched.json").write_text(json.dumps(td, indent=2))
          print("‚úÖ Patched:", container_name, "->", image_uri)
          PY

      - name: Register new task definition revision
        shell: bash
        run: |
          set -euo pipefail
          NEW_TASKDEF_ARN=$(aws ecs register-task-definition \
            --region "$AWS_REGION" \
            --cli-input-json file://taskdef_patched.json \
            --query "taskDefinition.taskDefinitionArn" \
            --output text)
          echo "NEW_TASKDEF_ARN=$NEW_TASKDEF_ARN" >> "$GITHUB_ENV"
          echo "‚úÖ New task definition: $NEW_TASKDEF_ARN"

      - name: Wait for service to be ACTIVE (if needed)
        shell: bash
        run: |
          set -euo pipefail
          MAX_WAIT=300  # 5 minutes
          ELAPSED=0
          
          # Check current service status
          STATUS=$(aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --query 'services[0].status' \
            --output text 2>/dev/null || echo "UNKNOWN")
          
          echo "üìä Current service status: $STATUS"
          
          if [ "$STATUS" = "ACTIVE" ]; then
            echo "‚úÖ Service is already ACTIVE, proceeding..."
            exit 0
          fi
          
          if [ "$STATUS" = "INACTIVE" ]; then
            echo "‚ö†Ô∏è  Service is INACTIVE. Attempting to activate..."
            # Try to update service with desired count 1 to activate it
            aws ecs update-service \
              --region "$AWS_REGION" \
              --cluster "$CLUSTER" \
              --service "$SERVICE" \
              --desired-count 1 \
              --task-definition "$NEW_TASKDEF_ARN" \
              --force-new-deployment >/dev/null 2>&1 || echo "‚ö†Ô∏è  Could not activate service automatically"
          fi
          
          # Wait for service to become ACTIVE
          echo "‚è≥ Waiting for service to become ACTIVE (max ${MAX_WAIT}s)..."
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(aws ecs describe-services \
              --region "$AWS_REGION" \
              --cluster "$CLUSTER" \
              --services "$SERVICE" \
              --query 'services[0].status' \
              --output text 2>/dev/null || echo "UNKNOWN")
            
            if [ "$STATUS" = "ACTIVE" ]; then
              echo "‚úÖ Service is now ACTIVE"
              exit 0
            fi
            
            echo "‚è≥ Service status: $STATUS (${ELAPSED}s/${MAX_WAIT}s)..."
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          echo "‚ö†Ô∏è  Service did not become ACTIVE within $MAX_WAIT seconds"
          echo "üìä Final status: $STATUS"
          echo "‚ö†Ô∏è  Continuing anyway - update-service may still work..."

      - name: Update ECS service
        shell: bash
        run: |
          set -euo pipefail
          aws ecs update-service \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --service "$SERVICE" \
            --task-definition "$NEW_TASKDEF_ARN" \
            --force-new-deployment

      - name: Wait for service to stabilize
        id: wait
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          aws ecs wait services-stable \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE"

      - name: Debug if not stable (events + stopped tasks)
        if: steps.wait.outcome != 'success'
        shell: bash
        run: |
          set -euo pipefail
          echo "‚ùå Service did not stabilize. Dumping debug info..."

          echo "== describe-services =="
          aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --output json

          echo "== list STOPPED tasks =="
          STOPPED=$(aws ecs list-tasks \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --service-name "$SERVICE" \
            --desired-status STOPPED \
            --max-results 5 \
            --query "taskArns[]" \
            --output text || true)

          echo "STOPPED tasks: $STOPPED"

          if [[ -n "$STOPPED" ]]; then
            echo "== describe STOPPED tasks =="
            aws ecs describe-tasks \
              --region "$AWS_REGION" \
              --cluster "$CLUSTER" \
              --tasks $STOPPED \
              --output json
          fi

          exit 1

      - name: Print service status
        shell: bash
        run: |
          set -euo pipefail
          aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --query "services[0].{desired:desiredCount,running:runningCount,pending:pendingCount,taskDef:taskDefinition,status:status,deployments:deployments}" \
            --output json
