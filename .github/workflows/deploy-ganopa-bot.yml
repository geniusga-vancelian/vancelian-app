name: Deploy Ganopa Bot (ECS Fargate - DEV)

on:
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: me-central-1
  AWS_ACCOUNT_ID: "411714852748"

  # ✅ DEV (tes vrais noms AWS)
  CLUSTER: vancelian-dev-api-cluster
  SERVICE: vancelian-dev-api-svc

  # ✅ ECR repo (mets le bon si tu en as déjà un)
  ECR_REPO_NAME: ganopa-bot

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::411714852748:role/GitHubDeployRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve image uri
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_TAG="${GITHUB_SHA}"
          IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}:${IMAGE_TAG}"
          {
            echo "IMAGE_TAG=${IMAGE_TAG}"
            echo "IMAGE_URI=${IMAGE_URI}"
          } >> "$GITHUB_ENV"
          echo "IMAGE_URI=${IMAGE_URI}"

      - name: Sanity check - ECS service exists
        shell: bash
        run: |
          set -euo pipefail
          aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --output json > svc.json

          FAILURES_COUNT=$(python - <<'PY'
          import json
          d=json.load(open("svc.json"))
          print(len(d.get("failures", [])))
          PY
          )
          if [[ "$FAILURES_COUNT" != "0" ]]; then
            echo "❌ ECS service not found: $SERVICE in cluster $CLUSTER"
            cat svc.json
            exit 1
          fi
          echo "✅ ECS service exists."

      - name: Ensure ECR repository exists
        shell: bash
        run: |
          set -euo pipefail
          if aws ecr describe-repositories \
              --region "$AWS_REGION" \
              --repository-names "$ECR_REPO_NAME" >/dev/null 2>&1; then
            echo "✅ ECR repo exists: ${ECR_REPO_NAME}"
          else
            echo "⚠️ ECR repo missing, creating: ${ECR_REPO_NAME}"
            aws ecr create-repository \
              --region "$AWS_REGION" \
              --repository-name "$ECR_REPO_NAME" \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256 >/dev/null
            echo "✅ Created ECR repo: ${ECR_REPO_NAME}"
          fi

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & push Docker image
        shell: bash
        run: |
          set -euo pipefail
          docker build -t "$IMAGE_URI" -f services/ganopa-bot/Dockerfile services/ganopa-bot
          docker push "$IMAGE_URI"

      - name: Fetch current task definition ARN
        shell: bash
        run: |
          set -euo pipefail
          TASKDEF_ARN=$(aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --query "services[0].taskDefinition" \
            --output text)

          echo "TASKDEF_ARN=$TASKDEF_ARN" >> $GITHUB_ENV
          echo "TASKDEF_ARN=$TASKDEF_ARN"

      - name: Download task definition JSON
        shell: bash
        run: |
          set -euo pipefail
          aws ecs describe-task-definition \
            --region "$AWS_REGION" \
            --task-definition "$TASKDEF_ARN" \
            --query "taskDefinition" \
            --output json > taskdef.json

      - name: Patch task definition image (container api)
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import json, os
          from pathlib import Path

          td = json.loads(Path("taskdef.json").read_text())

          for k in [
            "taskDefinitionArn","revision","status","requiresAttributes","compatibilities",
            "registeredAt","registeredBy"
          ]:
            td.pop(k, None)

          image_uri = os.environ["IMAGE_URI"]

          # ⚠️ on patch uniquement le container nommé "api" (comme dans ton ECS)
          patched = False
          for c in td.get("containerDefinitions", []):
            if c.get("name") == "api":
              c["image"] = image_uri
              patched = True

          if not patched:
            raise SystemExit("Container 'api' not found in task definition. Check container name in ECS.")

          Path("taskdef_patched.json").write_text(json.dumps(td, indent=2))
          print("Patched image:", image_uri)
          PY

      - name: Register new task definition revision
        shell: bash
        run: |
          set -euo pipefail
          NEW_TASKDEF_ARN=$(aws ecs register-task-definition \
            --region "$AWS_REGION" \
            --cli-input-json file://taskdef_patched.json \
            --query "taskDefinition.taskDefinitionArn" \
            --output text)
          echo "NEW_TASKDEF_ARN=$NEW_TASKDEF_ARN" >> $GITHUB_ENV
          echo "NEW_TASKDEF_ARN=$NEW_TASKDEF_ARN"

      - name: Update ECS service
        shell: bash
        run: |
          set -euo pipefail
          aws ecs update-service \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --service "$SERVICE" \
            --task-definition "$NEW_TASKDEF_ARN" \
            --force-new-deployment

      - name: Wait for service to stabilize
        shell: bash
        run: |
          set -euo pipefail
          aws ecs wait services-stable \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE"

      - name: Print service status
        shell: bash
        run: |
          set -euo pipefail
          aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --query "services[0].{desired:desiredCount,running:runningCount,pending:pendingCount,taskDef:taskDefinition,status:status}" \
            --output json
