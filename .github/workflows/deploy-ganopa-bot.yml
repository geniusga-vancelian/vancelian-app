name: Deploy Ganopa Bot (ECS Fargate)

on:
  push:
    branches: [ "main" ]
    paths:
      - "services/ganopa-bot/**"
      - ".github/workflows/deploy-ganopa-bot.yml"
  workflow_dispatch:
    inputs:
      target_env:
        description: "dev | staging | prod"
        required: true
        default: "dev"
        type: choice
        options: [dev, staging, prod]

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: me-central-1
  AWS_ACCOUNT_ID: "411714852748"
  ECR_REPO_NAME: ganopa-bot

  # IMPORTANT: le nom du container dans la Task Definition Ganopa
  # (à corriger: ce n'est pas "api" ici)
  CONTAINER_NAME: ganopa-bot

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::411714852748:role/GitHubDeployRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve env -> ECS names
        shell: bash
        run: |
          set -euo pipefail

          # Use input if provided (manual dispatch), otherwise default to "dev" (automatic push)
          TARGET_ENV="${{ inputs.target_env || 'dev' }}"

          case "$TARGET_ENV" in
            dev)
              # Ganopa DEV
              CLUSTER="vancelian-dev-api-cluster"
              SERVICE="ganopa-dev-bot-svc"
              ;;
            staging)
              # Ganopa STAGING (à adapter si tes noms diffèrent)
              CLUSTER="vancelian-staging-api-cluster"
              SERVICE="ganopa-staging-bot-svc"
              ;;
            prod)
              # Ganopa PROD (à adapter si tes noms diffèrent)
              CLUSTER="vancelian-prod-api-cluster"
              SERVICE="ganopa-prod-bot-svc"
              ;;
            *)
              echo "Unknown env" >&2; exit 1;;
          esac

          IMAGE_TAG="${GITHUB_SHA}"
          IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}:${IMAGE_TAG}"

          {
            echo "CLUSTER=${CLUSTER}"
            echo "SERVICE=${SERVICE}"
            echo "IMAGE_TAG=${IMAGE_TAG}"
            echo "IMAGE_URI=${IMAGE_URI}"
          } >> "$GITHUB_ENV"

          echo "Resolved:"
          echo "  ENV=${TARGET_ENV}"
          echo "  CLUSTER=${CLUSTER}"
          echo "  SERVICE=${SERVICE}"
          echo "  CONTAINER_NAME=${CONTAINER_NAME}"
          echo "  IMAGE_URI=${IMAGE_URI}"

      - name: Sanity check - ECS service exists
        shell: bash
        run: |
          set -euo pipefail
          aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --output json > svc.json

          FAILURES_COUNT=$(python - <<'PY'
          import json
          d=json.load(open("svc.json"))
          print(len(d.get("failures", [])))
          PY
          )

          if [[ "$FAILURES_COUNT" != "0" ]]; then
            echo "❌ ECS service not found: $SERVICE in cluster $CLUSTER"
            cat svc.json
            exit 1
          fi

          echo "✅ ECS service exists."

      - name: Ensure ECR repository exists
        shell: bash
        run: |
          set -euo pipefail
          if aws ecr describe-repositories \
              --region "$AWS_REGION" \
              --repository-names "$ECR_REPO_NAME" >/dev/null 2>&1; then
            echo "✅ ECR repo exists: ${ECR_REPO_NAME}"
          else
            echo "⚠️ Creating ECR repo: ${ECR_REPO_NAME}"
            aws ecr create-repository \
              --region "$AWS_REGION" \
              --repository-name "$ECR_REPO_NAME" \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256 >/dev/null
          fi

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & push Docker image
        shell: bash
        run: |
          set -euo pipefail
          docker build -t "$IMAGE_URI" -f services/ganopa-bot/Dockerfile services/ganopa-bot
          docker push "$IMAGE_URI"

      - name: Fetch current task definition ARN
        shell: bash
        run: |
          set -euo pipefail
          TASKDEF_ARN=$(aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --query "services[0].taskDefinition" \
            --output text)

          echo "TASKDEF_ARN=$TASKDEF_ARN" >> "$GITHUB_ENV"
          echo "TASKDEF_ARN resolved to: $TASKDEF_ARN"

      - name: Download task definition JSON
        shell: bash
        run: |
          set -euo pipefail
          aws ecs describe-task-definition \
            --region "$AWS_REGION" \
            --task-definition "$TASKDEF_ARN" \
            --query "taskDefinition" \
            --output json > taskdef.json

      - name: Patch task definition image (by container name)
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import json, os
          from pathlib import Path

          td = json.loads(Path("taskdef.json").read_text())

          for k in [
            "taskDefinitionArn","revision","status","requiresAttributes","compatibilities",
            "registeredAt","registeredBy"
          ]:
            td.pop(k, None)

          image_uri = os.environ["IMAGE_URI"]
          container_name = os.environ["CONTAINER_NAME"]

          found = False
          for c in td.get("containerDefinitions", []):
            if c.get("name") == container_name:
              c["image"] = image_uri
              found = True
              break

          if not found:
            names = [c.get("name") for c in td.get("containerDefinitions", [])]
            raise SystemExit(f"❌ Container '{container_name}' not found. Found: {names}")

          Path("taskdef_patched.json").write_text(json.dumps(td, indent=2))
          print("✅ Patched:", container_name, "->", image_uri)
          PY

      - name: Register new task definition revision
        shell: bash
        run: |
          set -euo pipefail
          NEW_TASKDEF_ARN=$(aws ecs register-task-definition \
            --region "$AWS_REGION" \
            --cli-input-json file://taskdef_patched.json \
            --query "taskDefinition.taskDefinitionArn" \
            --output text)
          echo "NEW_TASKDEF_ARN=$NEW_TASKDEF_ARN" >> "$GITHUB_ENV"
          echo "✅ New task definition: $NEW_TASKDEF_ARN"

      - name: Update ECS service
        shell: bash
        run: |
          set -euo pipefail
          aws ecs update-service \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --service "$SERVICE" \
            --task-definition "$NEW_TASKDEF_ARN" \
            --force-new-deployment

      - name: Wait for service to stabilize
        id: wait
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          aws ecs wait services-stable \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE"

      - name: Debug if not stable (events + stopped tasks)
        if: steps.wait.outcome != 'success'
        shell: bash
        run: |
          set -euo pipefail
          echo "❌ Service did not stabilize. Dumping debug info..."

          echo "== describe-services =="
          aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --output json

          echo "== list STOPPED tasks =="
          STOPPED=$(aws ecs list-tasks \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --service-name "$SERVICE" \
            --desired-status STOPPED \
            --max-results 5 \
            --query "taskArns[]" \
            --output text || true)

          echo "STOPPED tasks: $STOPPED"

          if [[ -n "$STOPPED" ]]; then
            echo "== describe STOPPED tasks =="
            aws ecs describe-tasks \
              --region "$AWS_REGION" \
              --cluster "$CLUSTER" \
              --tasks $STOPPED \
              --output json
          fi

          exit 1

      - name: Print service status
        shell: bash
        run: |
          set -euo pipefail
          aws ecs describe-services \
            --region "$AWS_REGION" \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --query "services[0].{desired:desiredCount,running:runningCount,pending:pendingCount,taskDef:taskDefinition,status:status,deployments:deployments}" \
            --output json
